---
title: Bidirectional Checking
collect: true
---

至此，我们已经完整地剖析了本文的第一项重点：局部类型参数合成。它通过一套由「变量消去」、「约束生成」和「参数计算」构成的、逻辑严密且完全可执行的算法，完美地解决了由细粒度多命题所引发的类型参数标注繁琐的问题，达成了引言中所述三条设计准则中的第一条。

然而，我们的工具箱尚不完备。回顾引言中基于 ML 代码分析所提出的三条设计准则，仍有两项亟待解决：

1. **高阶编程的便利性**：如何推断匿名函数（如 `fun[](x) x+1`）中绑定变量 `x` 的类型？
2. **纯函数式风格的支持**：如何让大量的局部变量绑定（如 `let x = ...`）无需显式类型标注？

局部类型参数合成机制，其信息流本质上是**自下而上**（bottom-up）的，它根据函数和参数的既有类型，向上推导出一个最佳的结果类型。这套机制，对于上述两个问题鞭长莫及，因为在类似 `fun[](x) x+1` 这样的表达式中，没有任何子结构能为 `x` 的类型提供信息。

我们考虑一种在思想上与前者互补的、功能强大的局部推断技术。它不再仅仅依赖自下而上的信息综合，而是引入了一股**自上而下（top-down）**的信息流，让表达式所处的**语境（context）**来指导其内部的类型检查。这便是**双向类型检查（Bidirectional Type Checking）**，其基本思想虽早已是编程语言社区的「民间共识」，并在一些基于属性文法的 ML 编译器中得以应用，本文将其在一个同时包含子类型化与非直谓多态的形式系统中进行严谨的公理化，并将其作为一种独立的局部推断方法，其威力出人意料地强大。

#### **两种模式：综合与检查**

1. **综合模式 (Synthesis Mode, $\Rightarrow$)**

   - 在此模式下，类型信息**自下而上传播**。
   - 其目标是根据一个表达式的子表达式的类型，来计算（或「综合」）出该表达式自身的类型。
   - 这对应于传统的类型检查方式，适用于那些我们对其期望类型一无所知的上下文，例如在处理一个顶层表达式或一个应用节点的函数部分时。

2. **检查模式 (Checking Mode, $\Leftarrow$)**
   - 在此模式下，类型信息**自上而下传播**。
   - 其目标是验证（或「检查」）一个表达式是否拥有一个由其所处语境提供的「期望类型」（或者该期望类型的一个子类型）。
   - 当一个表达式所处的语境已经决定了它的类型时，便可切换至此模式。

双向检查的精髓在于两种模式的灵活切换。一个典型的函数应用 `f(e)` 完美地展示了这一过程：类型检查器会先**综合**出函数 `f` 的类型，然后利用该类型提供的信息，切换模式去**检查**参数 `e`。

[+](/blog/lti/bidi_rules.md#:embed)

最后的实现即是落到 `synthesis` 和 `check` 两个关键函数上，
这是本文最重要的一个练习，
强烈建议读者自己尝试实现这两个函数，来体会双向检查的精妙之处，
并从中学习将类型规则转化为代码的技巧。

[+-](/blog/lti/bidi_code.md#:embed)

最后一个关键目标是局部变量绑定的设计，
这要求我们引入新的语法结构 `ELet`，但其规则是显然的：

$$
\frac{\Gamma \vdash e \Rightarrow S \quad \Gamma, x:S \vdash b \Rightarrow T}{\Gamma \vdash \textbf{let } x = e \textbf{ in } b \Rightarrow T} \quad (\text{S-Let})
$$

$$
\frac{\Gamma \vdash e \Rightarrow S \quad \Gamma, x:S \vdash b \Leftarrow T}{\Gamma \vdash \textbf{let } x = e \textbf{ in } b \Leftarrow T} \quad (\text{C-Let})
$$

实现留作习题。